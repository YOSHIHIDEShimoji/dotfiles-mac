c() {
    local time_opt=""
    local include_compile=0
    local cc_flags=()
    local explicit_out=""
    local format=""

    # 引数解析
    while [[ "$1" == -* ]]; do
        case "$1" in
            -p|-v) time_opt="$1"; shift ;;
            -f) time_opt="-f"; format="$2"; shift 2 ;;
            -T) include_compile=1; shift ;;
            -o) 
                # 出力先の手動指定 (-o) を検知
                [[ -n "$2" ]] || { echo "missing arg for $1"; return 1; }
                explicit_out="$2"
                shift 2 
                ;;
            -D|-I)
                [[ -n "$2" ]] || { echo "missing arg for $1"; return 1; }
                cc_flags+=("$1$2")
                shift 2
                ;;
            # コンパイルオプション群
            -D*|-I*|-O*|-W*|-std=*|-march=*|-mtune=*|-g|-ggdb|-fsanitize=*|-fno-*|-pthread)
                cc_flags+=("$1")
                shift
                ;;
            -- | -) shift; break ;; # - は標準入力等のためbreak
            *) break ;;
        esac
    done

    # 入力ファイルチェック
    if [[ ! "$1" == *.c ]]; then
        echo "Usage: c [-p|-v|-f FORMAT|-T] [-o OUT] [-D...|-I...|-O...] file.c [args...]"
        return 1
    fi

    local src="$(realpath "$1")"
    shift # 残りは実行時の引数へ

    local name="$(basename "${src%.c}")"
    local out=""

    # 出力パスの決定ロジック
    if [[ -n "$explicit_out" ]]; then
        # -o が指定された場合はそのパスに従う (カレントディレクトリ等)
        out="$explicit_out"
    else
        # 指定がない場合は /tmp に保存
        # mktemp を使うことでファイル名の衝突を防ぐ
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            out="$(mktemp /tmp/${name}.XXXXXX)"
        else
            # Linux
            out="$(mktemp --tmpdir /tmp ${name}.XXXXXX)"
        fi
        # コンパイル失敗時にゴミが残らないようトラップしても良いが、
        # 今回はシンプルに「コンパイル成功したら上書き」の挙動にするためそのまま
    fi

    # math.h の自動リンク
    local compile_cmd=""
    if grep -q '#[[:space:]]*include[[:space:]]*<math\.h>' "$src"; then
        compile_cmd="cc ${cc_flags:+${(j: :)cc_flags}} \"$src\" -o \"$out\" -lm"
    else
        compile_cmd="cc ${cc_flags:+${(j: :)cc_flags}} \"$src\" -o \"$out\""
    fi

    # タイム計測コマンドの選定
    local TIME_CMD=""
    if command -v gtime &>/dev/null; then
        TIME_CMD="gtime"
    else
        TIME_CMD="/usr/bin/time"
    fi

    # macOS の /usr/bin/time は -v がなく -l が相当
    if [[ "$OSTYPE" == "darwin"* && "$time_opt" == "-v" && "$TIME_CMD" == "/usr/bin/time" ]]; then
        time_opt="-l"
    fi

    # コンパイルと実行
    # 実行用のラッパー関数を定義して重複を避ける
    run_binary() {
        if [[ -n "$time_opt" ]]; then
            local tmp_time="$(mktemp)"
            if [[ "$time_opt" == "-f" ]]; then
                $TIME_CMD -o "$tmp_time" -f "$format" "$@"
            else
                $TIME_CMD -o "$tmp_time" $time_opt "$@"
            fi
            # 実行終了後にタイムを表示
            local ret=$?
            echo
            echo "======= TIME RESULT ======="
            sed 's/^/  /' "$tmp_time"
            rm -f "$tmp_time"
            return $ret
        else
            "$@"
        fi
    }

    if [[ $include_compile -eq 1 ]]; then
        # コンパイル時間も含めて計測する場合
        # sh -c でまとめて渡す必要がある
        local shell_cmd="$compile_cmd && \"$out\""
        # 引数 ($@) の展開が sh -c 内で複雑になるため、コンパイル時間計測モードでは
        # 実行引数の扱いに注意が必要（簡易化のためここでは単純結合）
        # ※厳密にやるなら配列展開が必要だが、今回は既存ロジックを踏襲
        run_binary sh -c "$shell_cmd $*"
    else
        # コンパイルのみ先に実行
        eval "$compile_cmd" || return 1
        # 実行
        run_binary "$out" "$@"
    fi
}
