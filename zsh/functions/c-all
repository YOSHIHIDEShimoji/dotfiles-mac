c-all() {
  setopt localoptions null_glob
  OPTIND=1
  local quiet=0
  local dryrun=0
  local recursive=0
  local match="*.c"
  local dir="."
  local rc=0

  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo "Usage: c-all [-q] [-n] [-r] [-m pattern] [path]"
    echo "  -q           Quiet mode (suppress headers)"
    echo "  -n           Dry run (list files only)"
    echo "  -r           Search recursively"
    echo "  -m pattern   Match pattern (default: *.c)"
    echo "  [path]       Directory to search (default: .)"
    return 0
  fi

  while getopts "qnm:r" opt; do
    case "$opt" in
      q) quiet=1 ;;
      n) dryrun=1 ;;
      m) match="$OPTARG" ;;
      r) recursive=1 ;;
      *) echo "Usage: c-all [-q] [-n] [-r] [-m pattern] [path]" >&2; return 1 ;;
    esac
  done
  shift $((OPTIND - 1))

  [[ -n "$1" ]] && dir="$1"
  [[ -d "$dir" ]] || { echo "Error: directory not found: $dir" >&2; return 1; }

  local -a files
  if (( recursive )); then
    if [[ "$match" == *"/"* ]]; then
      files=("${(@f)$(find "$dir" -type d \( -name .git -o -name build -o -name node_modules \) -prune -o -type f -path "$dir/$match" -print 2>/dev/null | LC_ALL=C sort)}")
    else
      files=("${(@f)$(find "$dir" -type d \( -name .git -o -name build -o -name node_modules \) -prune -o -type f -name "$match" -print 2>/dev/null | LC_ALL=C sort)}")
    fi
  else
    files=($dir/${~match}(N))
    files=("${(on)files}")
  fi

  if (( ${#files[@]} == 0 )); then
    (( quiet )) || echo "(no matches for $dir/$match)"
    return 0
  fi

  if (( ! dryrun )); then
    command -v c >/dev/null 2>&1 || { echo "Error: 'c' command not found" >&2; return 127; }
  fi

  local file status
  for file in "${files[@]}"; do
    [[ -f "$file" ]] || continue
    if (( dryrun )); then
      echo "$file"
      continue
    fi
    if (( quiet )); then
      C_NO_CLEAR=1 c "$file"
      status=$?
    else
      echo "==> $file <=="
      C_NO_CLEAR=1 c "$file"
      status=$?
      echo
    fi
    (( status != 0 )) && rc=$status
  done

  return $rc
}
