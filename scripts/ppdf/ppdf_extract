#!/bin/bash

usage() {
    cat << EOF
Usage: $(basename "$0") [-o OUTPUT.pdf] [-n] INPUT.pdf extra.txt

PDFから特定のページを抽出します。
※ odd/even がある場合のみPythonで計算し、それ以外は高速に処理します。

Arguments:
  INPUT.pdf       元のPDF
  extra.txt       ページ指定リスト
                  Simple : 1, 3, 5-10, z, r1 (シェル処理・高速)
                  Complex: 1-10[odd], z[even] (Python処理・展開)

Options:
  -h, --help      ヘルプを表示
  -o OUTPUT.pdf   出力ファイル名を指定
  -n, --no-sort   ソートを無効にする (z, r を含む場合は自動で無効)
EOF
    exit 0
}

OUTPUT=""
NO_SORT=false
FILES=()

# --- オプション解析 ---
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -h|--help) usage ;;
        -o|--output) OUTPUT="$2"; shift 2 ;;
        -n|--no-sort) NO_SORT=true; shift ;;
        -*) echo "Error: 不明なオプション $1"; usage ;;
        *) FILES+=("$1"); shift ;;
    esac
done

set -- "${FILES[@]}"
if [[ $# -ne 2 ]]; then usage; fi

INPUT_PDF="$1"
LIST_FILE="$2"

if [[ ! -f "$INPUT_PDF" || ! -f "$LIST_FILE" ]]; then
    echo "Error: ファイルが見つかりません。"; exit 1
fi

[ -z "$OUTPUT" ] && OUTPUT="${INPUT_PDF%.*}_extracted.pdf"

# ファイルの中身を読み込む
RAW_CONTENT=$(cat "$LIST_FILE")
if [ -z "$RAW_CONTENT" ]; then
    echo "Error: ページ指定が空です。"; exit 1
fi

# --- 分岐判定 ---
# "odd" または "even" が含まれているかチェック
if [[ "$RAW_CONTENT" =~ (odd|even) ]]; then
    
    # === [Mode A] Pythonルート (odd/evenの計算が必要) ===
    echo "Complex pattern detected (odd/even). Using Python expansion..."
    
    if ! command -v qpdf &> /dev/null; then echo "Error: qpdfが必要です"; exit 1; fi
    MAX_PAGES=$(qpdf --show-npages "$INPUT_PDF" 2>/dev/null)
    
    # Pythonで展開 (前回のロジック)
    PARSED_PAGES=$(python3 -c "
import sys, re
max_p = int('$MAX_PAGES')
raw = sys.stdin.read()
tokens = re.split(r'[,\s\n\t]+', raw)
result = []

def parse_val(v):
    if v == 'z': return max_p
    if v.startswith('r'):
        try: return max_p - int(v[1:]) + 1
        except: return max_p
    return int(v)

for t in tokens:
    if not t: continue
    mode = 'odd' if '[odd]' in t else 'even' if '[even]' in t else None
    clean_t = re.sub(r'\[.*?\]', '', t)
    
    if '-' in clean_t:
        try:
            s_str, e_str = clean_t.split('-')
            s, e = parse_val(s_str), parse_val(e_str)
            step = 1 if s <= e else -1
            rng = range(s, e + step, step)
            if mode == 'odd': rng = [x for x in rng if x % 2 != 0]
            elif mode == 'even': rng = [x for x in rng if x % 2 == 0]
            result.extend(map(str, rng))
        except: pass
    else:
        try:
            val = parse_val(clean_t)
            if mode == 'odd' and val % 2 == 0: continue
            if mode == 'even' and val % 2 != 0: continue
            result.append(str(val))
        except: pass

print(','.join(result))
" <<< "$RAW_CONTENT")

else
    # === [Mode B] Shellルート (高速・単純整形のみ) ===
    # odd/evenが含まれないなら、[]などのゴミを取り除いてカンマ区切りにするだけ
    
    # 1. [] で囲まれた部分（無効なタグなど）を削除
    # 2. タブ・改行・スペースをカンマに変換
    # 3. 連続カンマを整理
    PARSED_PAGES=$(echo "$RAW_CONTENT" \
        | sed 's/\[[^]]*\]//g' \
        | tr '\t\n ' ',,,' \
        | sed -E 's/,+/,/g' \
        | sed 's/^,//;s/,$//')
        
    # z や r がある場合は自動ソート無効化
    if [[ "$PARSED_PAGES" =~ [zr] ]]; then
        if [ "$NO_SORT" = false ]; then
            echo "Note: 'z' or 'r' detected. Disabling auto-sort."
            NO_SORT=true
        fi
    fi
fi

if [ -z "$PARSED_PAGES" ]; then
    echo "Error: 有効なページ指定がありません。"; exit 1
fi

# --- ソート処理 ---
if [ "$NO_SORT" = true ]; then
    FINAL_PAGES="$PARSED_PAGES"
else
    # カンマ区切り -> 改行 -> 数値ソート -> カンマ結合
    FINAL_PAGES=$(echo "$PARSED_PAGES" | tr ',' '\n' | sort -n -k1,1 2>/dev/null | uniq | paste -sd "," -)
fi

echo "Extracting: $FINAL_PAGES"

# 実行
qpdf "$INPUT_PDF" --pages . "$FINAL_PAGES" -- "$OUTPUT" && echo "Done! -> $OUTPUT"